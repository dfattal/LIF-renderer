<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LIF Renderer Demo</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 5px;
      z-index: 100;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="info">
    LIF Renderer Demo<br>
    FPS: <span id="fps">60</span><br>
    Points: <span id="point-count">0</span><br>
    Mode: <span id="mode">Free Camera</span><br>
    <span id="orbit-center-display" style="display: none;">Orbit: <span id="orbit-center-pos">(0.000, 0.000, 0.000)</span><br></span>
    Pos: <span id="camera-pos">(0.000, 0.000, 0.000)</span><br>
    Fwd: <span id="camera-forward">(0.000, 0.000, -1.000)</span><br>
    <div style="margin-top: 10px;">
      Gradient Filter: <span id="gradient-enabled">ON</span><br>
      <div id="gradient-threshold-container">
        Threshold: <span id="gradient-value">0.0090</span><br>
        <input type="range" id="gradient-slider" min="0" max="200" value="100" step="1" style="width: 200px;">
      </div>
    </div>
    <span id="controls"></span>
  </div>

  <div id="texture-debug" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 10px; z-index: 200; display: none; max-width: 90vw; max-height: 90vh; overflow-y: auto; overflow-x: hidden;">
    <div style="position: sticky; top: 0; background: rgba(0, 0, 0, 0.95); padding-bottom: 10px; z-index: 1; text-align: right; margin-bottom: 10px;">
      <button id="close-texture-debug" style="background: #ff4444; color: white; border: none; padding: 5px 15px; border-radius: 5px; cursor: pointer;">Close (X)</button>
    </div>
    <div id="texture-debug-content" style="color: white; font-family: monospace; font-size: 12px;"></div>
  </div>

  <div id="lif-loader" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 5px; color: white; font-family: monospace; z-index: 100; max-width: 300px;">
    <div style="margin-bottom: 8px;">Load LIF File:</div>
    <input type="file" id="lif-file-input" accept=".lif,.jpg,.jpeg,image/jpeg" style="width: 200px;">
    <div id="lif-status" style="margin-top: 8px; font-size: 12px; color: #aaa;">LIF = JPEG with metadata</div>

    <div id="view-selector" style="margin-top: 10px; display: none;">
      <label style="font-size: 12px;">
        View:
        <select id="view-select" style="margin-left: 5px; background: #333; color: white; border: 1px solid #555; padding: 2px 5px;">
          <option value="0">View 0</option>
        </select>
      </label>
    </div>

    <div id="xr-container" style="margin-top: 15px; display: none;">
      <button id="xr-button" style="width: 100%; background: #0066ff; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">
        Enter VR
      </button>
      <div id="xr-status" style="margin-top: 8px; font-size: 11px; color: #aaa; text-align: center;">
        XR Ready
      </div>
    </div>

    <div id="view-info" style="margin-top: 15px; font-size: 11px; line-height: 1.4; border-top: 1px solid #555; padding-top: 10px; display: none;">
      <div style="font-weight: bold; margin-bottom: 5px;">Projector Pose:</div>
      <div>Pos: <span id="view-pos">-</span></div>
      <div>Rot: <span id="view-rot">-</span></div>

      <div style="font-weight: bold; margin-top: 8px; margin-bottom: 3px;">Main View:</div>
      <div>Size: <span id="main-width">-</span> × <span id="main-height">-</span> px</div>
      <div>Focal: <span id="main-focal">-</span> px</div>

      <div style="font-weight: bold; margin-top: 8px; margin-bottom: 3px;">Layer 0:</div>
      <div>Size: <span id="layer0-width">-</span> × <span id="layer0-height">-</span> px</div>
      <div>Focal: <span id="layer0-focal">-</span> px</div>

      <div style="font-weight: bold; margin-top: 8px; margin-bottom: 3px;">Depth Range:</div>
      <div>invZ min: <span id="view-invz-min">-</span></div>
      <div>invZ max: <span id="view-invz-max">-</span></div>
      <div>baseline: <span id="view-baseline">-</span> mm</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
    import { HoloProjector, HoloRenderer, loadLifFile } from "./src/index.ts";

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.0001,
      1e7  // Far plane at 10 million units to render distant raycast plane
    );
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x111111);
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Match monitor color space
    document.body.appendChild(renderer.domElement);

    // Enable XR support
    renderer.xr.enabled = true;

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // SFMoMA restaurant scene data
    const fullWidth = 1280;
    const fullHeight = 800;
    const width = fullWidth;
    const height = fullHeight;

    document.getElementById('point-count').textContent = (width * height).toLocaleString();

    // Create holographic projector (use let so we can replace it when loading LIF files)
    let projector = new HoloProjector({
      rgbUrl: './assets/rgb.jpg',
      depthUrl: './assets/depth.png',
      intrinsics: {
        fx: 0.78 * fullWidth,
        fy: 0.78 * fullWidth,
        cx: width / 2,
        cy: height / 2,
      },
      invDepthRange: {
        min: 0.09,
        max: 0.0001,
        baseline: 0.045,
      },
      width,
      height,
      onLoad: () => console.log('Projector loaded!')
    });

    scene.add(projector);

    // Store initial camera position and rotation for reset
    let initialCameraPosition = new THREE.Vector3(0, 0, 0);
    let initialCameraQuaternion = new THREE.Quaternion(0, 0, 0, 1);
    let initialOrbitCenter = null; // Store orbit center if view has valid invd
    let initialHasOrbitMode = false; // Track if this view should start in orbit mode

    // Store all loaded projectors from LIF file
    let loadedProjectors = [];
    // Store orbit center for each view (indexed by view index)
    let viewOrbitCenters = [];

    // XR camera height tracking
    let initialY = null;
    const INITIAL_Y_MIN_THRESHOLD = 0.5; // Minimum 0.5m to avoid invalid readings

    // Add helpers
    const axesHelper = new THREE.AxesHelper(0.5);
    projector.add(axesHelper);

    // Helper function to find HoloRenderer in scene
    function findHoloRenderer() {
      let renderer = null;
      scene.traverse((obj) => {
        if (obj instanceof HoloRenderer) {
          renderer = obj;
        }
      });
      return renderer;
    }

    // Function to show texture debug view
    function showTextureDebug() {
      const debugPanel = document.getElementById('texture-debug');
      const content = document.getElementById('texture-debug-content');

      if (!projector) {
        content.innerHTML = '<div style="color: #ff4444;">No projector loaded</div>';
        debugPanel.style.display = 'block';
        return;
      }

      console.log('Texture Debug - Projector:', projector);
      console.log('RGB Texture:', projector.rgbTexture, 'has image:', !!projector.rgbTexture?.image);
      console.log('Depth Texture:', projector.depthTexture, 'has image:', !!projector.depthTexture?.image);
      console.log('lifLayers count:', projector.lifLayers?.length);
      console.log('lifLayers detail:', projector.lifLayers);

      // Check each layer
      projector.lifLayers?.forEach((layer, i) => {
        console.log(`Layer ${i}:`, {
          rgbUrl: layer.rgbUrl,
          depthUrl: layer.depthUrl,
          maskUrl: layer.maskUrl,
          width: layer.width,
          height: layer.height,
          hasRgbTexture: !!layer.rgbTexture,
          hasDepthTexture: !!layer.depthTexture
        });
      });

      let html = '<div style="margin-bottom: 20px;">';
      html += `<h3 style="margin: 0 0 15px 0; color: #4CAF50;">Current View Textures</h3>`;
      html += `<div style="margin-bottom: 5px;">Dimensions: ${projector.width}x${projector.height}</div>`;
      html += `<div style="margin-bottom: 15px;">Layers: ${projector.lifLayers.length}</div>`;

      // First row: Main RGB and Depth
      html += '<div style="margin-bottom: 20px; border-bottom: 2px solid #666; padding-bottom: 15px;">';
      html += '<div style="margin-bottom: 10px; font-weight: bold; color: #FFD700;">Main View:</div>';
      html += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';

      // Main RGB - use image.src if available
      if (projector.rgbTexture && projector.rgbTexture.image) {
        const imgSrc = projector.rgbTexture.image.src || projector.rgbTexture.image.currentSrc;
        if (imgSrc) {
          html += `<div style="text-align: center;">
            <div style="margin-bottom: 5px; font-size: 11px;">RGB</div>
            <img src="${imgSrc}" style="max-width: 200px; max-height: 150px; border: 1px solid #666;" />
          </div>`;
        } else {
          html += `<div style="text-align: center; width: 200px;">
            <div style="margin-bottom: 5px; font-size: 11px;">RGB</div>
            <div style="width: 200px; height: 150px; border: 1px solid #ff4444; display: flex; align-items: center; justify-content: center; color: #ff4444;">No src</div>
          </div>`;
        }
      } else {
        html += `<div style="text-align: center; width: 200px;">
          <div style="margin-bottom: 5px; font-size: 11px;">RGB</div>
          <div style="width: 200px; height: 150px; border: 1px solid #666; display: flex; align-items: center; justify-content: center; color: #666;">No texture</div>
        </div>`;
      }

      // Main Depth - use image.src if available
      if (projector.depthTexture && projector.depthTexture.image) {
        const imgSrc = projector.depthTexture.image.src || projector.depthTexture.image.currentSrc;
        if (imgSrc) {
          html += `<div style="text-align: center;">
            <div style="margin-bottom: 5px; font-size: 11px;">Depth</div>
            <img src="${imgSrc}" style="max-width: 200px; max-height: 150px; border: 1px solid #666;" />
          </div>`;
        } else {
          html += `<div style="text-align: center; width: 200px;">
            <div style="margin-bottom: 5px; font-size: 11px;">Depth</div>
            <div style="width: 200px; height: 150px; border: 1px solid #ff4444; display: flex; align-items: center; justify-content: center; color: #ff4444;">No src</div>
          </div>`;
        }
      } else {
        html += `<div style="text-align: center; width: 200px;">
          <div style="margin-bottom: 5px; font-size: 11px;">Depth</div>
          <div style="width: 200px; height: 150px; border: 1px solid #666; display: flex; align-items: center; justify-content: center; color: #666;">No texture</div>
        </div>`;
      }

      html += '</div></div>';

      // Subsequent rows: Layers
      projector.lifLayers.forEach((layer, index) => {
        html += `<div style="margin-bottom: 20px; ${index < projector.lifLayers.length - 1 ? 'border-bottom: 1px solid #444;' : ''} padding-bottom: 15px;">`;
        html += `<div style="margin-bottom: 10px; font-weight: bold; color: #4FC3F7;">Layer ${index}:</div>`;
        html += `<div style="margin-bottom: 5px; font-size: 10px; color: #aaa;">${layer.width}x${layer.height}</div>`;
        html += '<div style="display: flex; gap: 10px; align-items: flex-start;">';

        // Layer RGB
        if (layer.rgbUrl) {
          html += `<div style="text-align: center; flex-shrink: 0;">
            <div style="margin-bottom: 5px; font-size: 11px;">RGB</div>
            <img src="${layer.rgbUrl}" style="max-width: 200px; max-height: 150px; border: 1px solid #666;" />
          </div>`;
        } else if (layer.rgbTexture && layer.rgbTexture.image) {
          const canvas = createTextureCanvas(layer.rgbTexture, 'RGB');
          html += `<div style="text-align: center; flex-shrink: 0;">
            <div style="margin-bottom: 5px; font-size: 11px;">RGB</div>
            ${canvas.outerHTML}
          </div>`;
        } else {
          html += `<div style="text-align: center; flex-shrink: 0; width: 200px;">
            <div style="margin-bottom: 5px; font-size: 11px;">RGB</div>
            <div style="width: 200px; height: 150px; border: 1px solid #666; display: flex; align-items: center; justify-content: center; color: #666;">No RGB</div>
          </div>`;
        }

        // Layer Depth
        if (layer.depthUrl) {
          html += `<div style="text-align: center; flex-shrink: 0;">
            <div style="margin-bottom: 5px; font-size: 11px;">Depth</div>
            <img src="${layer.depthUrl}" style="max-width: 200px; max-height: 150px; border: 1px solid #666;" />
          </div>`;
        } else if (layer.depthTexture && layer.depthTexture.image) {
          const canvas = createTextureCanvas(layer.depthTexture, 'Depth');
          html += `<div style="text-align: center; flex-shrink: 0;">
            <div style="margin-bottom: 5px; font-size: 11px;">Depth</div>
            ${canvas.outerHTML}
          </div>`;
        } else {
          html += `<div style="text-align: center; flex-shrink: 0; width: 200px;">
            <div style="margin-bottom: 5px; font-size: 11px;">Depth</div>
            <div style="width: 200px; height: 150px; border: 1px solid #666; display: flex; align-items: center; justify-content: center; color: #666;">No Depth</div>
          </div>`;
        }

        // Layer Mask
        if (layer.maskUrl) {
          html += `<div style="text-align: center; flex-shrink: 0;">
            <div style="margin-bottom: 5px; font-size: 11px;">Mask</div>
            <img src="${layer.maskUrl}" style="max-width: 200px; max-height: 150px; border: 1px solid #666;" />
          </div>`;
        } else {
          html += `<div style="text-align: center; flex-shrink: 0; width: 200px;">
            <div style="margin-bottom: 5px; font-size: 11px;">Mask</div>
            <div style="width: 200px; height: 150px; border: 1px solid #666; display: flex; align-items: center; justify-content: center; color: #666;">No Mask</div>
          </div>`;
        }

        html += '</div></div>';
      });

      html += '</div>';
      content.innerHTML = html;
      debugPanel.style.display = 'block';
    }

    // Helper to create a canvas from a THREE.Texture
    function createTextureCanvas(texture, label) {
      const canvas = document.createElement('canvas');
      const maxSize = 200;

      if (!texture.image) {
        console.error('Texture has no image:', label, texture);
        canvas.width = maxSize;
        canvas.height = maxSize;
        canvas.style.border = '1px solid #ff0000';
        return canvas;
      }

      const aspectRatio = texture.image.width / texture.image.height;

      if (aspectRatio > 1) {
        canvas.width = maxSize;
        canvas.height = maxSize / aspectRatio;
      } else {
        canvas.width = maxSize * aspectRatio;
        canvas.height = maxSize;
      }

      const ctx = canvas.getContext('2d');
      try {
        ctx.drawImage(texture.image, 0, 0, canvas.width, canvas.height);
      } catch (e) {
        console.error('Failed to draw texture:', label, e, texture);
      }
      canvas.style.border = '1px solid #666';

      return canvas;
    }

    // Close button handler
    document.getElementById('close-texture-debug').addEventListener('click', () => {
      document.getElementById('texture-debug').style.display = 'none';
    });

    // Camera controls
    const moveState = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      up: false,
      down: false,
    };

    const mouseSensitivity = 0.002;
    const moveSpeed = 1.0; // Reduced from 2.0 (2x less sensitive)
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');

    // Orbit mode state
    let isOrbitMode = false;
    let orbitCenter = new THREE.Vector3();
    let orbitDistance = 5.0;
    let orbitPhi = 0;
    let orbitTheta = 0;

    // Raycast hit marker (red sphere)
    let hitMarker = null;
    let hitMarkerVisible = true; // Default to visible
    function createHitMarker(position) {
      // Remove old marker if exists
      if (hitMarker) {
        scene.remove(hitMarker);
      }

      // Create red sphere at hit point
      const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        depthTest: true,
        depthWrite: true
      });
      hitMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      hitMarker.position.copy(position);
      hitMarker.visible = hitMarkerVisible;
      hitMarker.renderOrder = 1; // Render after most objects but before UI
      scene.add(hitMarker);
    }

    function toggleHitMarker() {
      if (hitMarker) {
        hitMarkerVisible = !hitMarkerVisible;
        hitMarker.visible = hitMarkerVisible;
        console.log('Orbit marker:', hitMarkerVisible ? 'visible' : 'hidden');
      }
    }

    // Camera animation state
    let isAnimating = false;
    let animationProgress = 0;
    let animationStartPos = new THREE.Vector3();
    let animationStartQuat = new THREE.Quaternion();
    let animationTargetPos = new THREE.Vector3();
    let animationTargetQuat = new THREE.Quaternion();
    const animationDuration = 0.5;

    // Detect device type and set controls text
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                     ('ontouchstart' in window) ||
                     (navigator.maxTouchPoints > 0);

    const controlsElement = document.getElementById('controls');

    // Function to update controls based on mode
    function updateControls(mode) {
      // Show/hide orbit center display
      const orbitCenterDisplay = document.getElementById('orbit-center-display');
      if (mode === 'orbit') {
        orbitCenterDisplay.style.display = 'inline';
        // Update orbit center position
        const orbitCenterPos = document.getElementById('orbit-center-pos');
        orbitCenterPos.textContent = `(${orbitCenter.x.toFixed(3)}, ${orbitCenter.y.toFixed(3)}, ${orbitCenter.z.toFixed(3)})`;
      } else {
        orbitCenterDisplay.style.display = 'none';
      }

      if (mode === 'free') {
        if (isMobile) {
          controlsElement.innerHTML =
            'Touch: Look around<br>' +
            'Double Tap: Orbit point<br>' +
            '2 Fingers: Pan/Zoom<br>' +
            'Long Press: Reset view';
        } else {
          const viewNavigation = loadedProjectors.length > 1 ? '←→: Switch views<br>' : '';
          controlsElement.innerHTML =
            'WASD+QE: Move camera<br>' +
            'Click+Drag: Look around<br>' +
            'Double Click: Orbit point<br>' +
            viewNavigation +
            'R: Reset view<br>' +
            'L: Toggle LDI mode<br>' +
            'M: Toggle Mono/Stereo<br>' +
            'V: Toggle depth view<br>' +
            'G: Toggle gradient filter<br>' +
            'X: Show textures<br>' +
            'F: Toggle frustum';
        }
      } else if (mode === 'orbit') {
        if (isMobile) {
          controlsElement.innerHTML =
            'Touch: Rotate orbit<br>' +
            'Pinch: Zoom<br>' +
            'Long Press: Reset view';
        } else {
          const viewNavigation = loadedProjectors.length > 1 ? '←→: Switch views<br>' : '';
          const markerStatus = hitMarker ? (hitMarkerVisible ? 'ON' : 'OFF') : 'N/A';
          controlsElement.innerHTML =
            'Click+Drag: Rotate orbit<br>' +
            'Wheel: Zoom<br>' +
            viewNavigation +
            'O: Toggle orbit marker (' + markerStatus + ')<br>' +
            'R: Reset view<br>' +
            'Escape: Exit orbit mode';
        }
      }
    }

    // Set initial controls for free camera mode
    updateControls('free');

    // Keyboard controls
    document.addEventListener('keydown', async (e) => {
      switch (e.code) {
        case 'KeyW': moveState.forward = true; break;
        case 'KeyS': moveState.backward = true; break;
        case 'KeyA': moveState.left = true; break;
        case 'KeyD': moveState.right = true; break;
        case 'KeyE': moveState.up = true; break;
        case 'KeyQ': moveState.down = true; break;
        case 'Escape':
          if (isOrbitMode) {
            isOrbitMode = false;
            isAnimating = false;
            document.getElementById('mode').textContent = 'Free Camera';
            updateControls('free');
          }
          break;
        case 'KeyF':
          projector.frustumHelper.visible = !projector.frustumHelper.visible;
          break;
        case 'KeyR':
          // Reset view to initial state (orbit mode if view has invd, otherwise free camera)
          camera.position.copy(initialCameraPosition);
          camera.quaternion.copy(initialCameraQuaternion);

          if (initialHasOrbitMode && initialOrbitCenter) {
            // Reset to orbit mode with the initial orbit center
            orbitCenter.copy(initialOrbitCenter);
            orbitDistance = camera.position.distanceTo(orbitCenter);

            const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
            orbitTheta = Math.atan2(offset.x, offset.z);
            orbitPhi = Math.acos(offset.y / orbitDistance);

            isOrbitMode = true;
            isAnimating = false;
            document.getElementById('mode').textContent = 'Orbit Mode';
            updateControls('orbit');

            // Ensure orbit marker exists and is visible
            if (!hitMarker) {
              createHitMarker(initialOrbitCenter);
            } else {
              hitMarker.position.copy(initialOrbitCenter);
              hitMarker.visible = hitMarkerVisible;
            }

            console.log('Reset to orbit mode at initial orbit center');
          } else {
            // Reset to free camera mode
            isOrbitMode = false;
            isAnimating = false;
            document.getElementById('mode').textContent = 'Free Camera';
            updateControls('free');
            console.log('Reset to free camera mode');
          }
          break;
        case 'KeyM':
          // Toggle Mono/Stereo raycast mode
          const holoRenderer5 = findHoloRenderer();
          if (holoRenderer5 && holoRenderer5.raycastPlane) {
            const newMode = await holoRenderer5.raycastPlane.toggleViewMode();
            const projectorCount = holoRenderer5.raycastPlane.getProjectorCount();

            if (newMode === 'stereo' && projectorCount >= 2) {
              console.log('Switched to STEREO raycast mode (using both views)');
              // Hide view selector in stereo mode
              document.getElementById('view-selector').style.display = 'none';
            } else {
              console.log('Switched to MONO raycast mode');
              // Show view selector in mono mode if multiple views available
              if (loadedProjectors.length > 1) {
                document.getElementById('view-selector').style.display = 'block';
              }
            }
          } else {
            console.log('Raycast plane not available - switch to raycast mode first with L key');
          }
          break;
        case 'KeyU':
          // Debug: Log all shader uniforms
          let foundPlane = false;
          // Search in scene (including camera children)
          camera.traverse((obj) => {
            if (obj.name === 'RaycastPlane') {
              console.log('=== RaycastPlane Debug ===');
              console.log('Position (local):', obj.position.toArray());
              console.log('Position (world):', obj.getWorldPosition(new THREE.Vector3()).toArray());
              console.log('Rotation:', obj.rotation.toArray().slice(0, 3));
              console.log('Visible:', obj.visible);
              console.log('Geometry:', obj.geometry.type,
                'vertices:', obj.geometry.attributes.position?.count || 0);
              console.log('Material:', obj.material.type,
                'transparent:', obj.material.transparent,
                'opacity:', obj.material.opacity);
              console.log('RenderOrder:', obj.renderOrder);
              console.log('Parent:', obj.parent?.type || 'none');

              if (typeof obj.logUniforms === 'function') {
                obj.logUniforms();
              }
              foundPlane = true;
            }
          });
          if (!foundPlane) {
            console.log('RaycastPlane not found in camera hierarchy');
            // Also check scene just in case
            scene.traverse((obj) => {
              if (obj.name === 'RaycastPlane') {
                console.log('Found RaycastPlane in scene (not camera)');
                foundPlane = true;
              }
            });
            if (!foundPlane) {
              console.log('RaycastPlane not found anywhere!');
            }
          }
          break;
        case 'KeyG':
          // Toggle gradient filter
          const holoRenderer2 = findHoloRenderer();
          if (holoRenderer2) {
            const currentThreshold = holoRenderer2.getGradientThreshold();
            const invZRange = 0.09 - 0.0001;
            const defaultThreshold = invZRange * 0.10;

            if (currentThreshold > 0.0) {
              // Turn off
              holoRenderer2.setGradientThreshold(0.0);
              document.getElementById('gradient-enabled').textContent = 'OFF';
              document.getElementById('gradient-threshold-container').style.display = 'none';
              console.log('Gradient filter: OFF');
            } else {
              // Turn on with default threshold
              holoRenderer2.setGradientThreshold(defaultThreshold);
              document.getElementById('gradient-enabled').textContent = 'ON';
              document.getElementById('gradient-threshold-container').style.display = 'block';
              document.getElementById('gradient-value').textContent = defaultThreshold.toFixed(4);
              document.getElementById('gradient-slider').value = '100';
              console.log('Gradient filter: ON');
            }
          }
          break;
        case 'KeyV':
          // Toggle depth visualization
          const holoRenderer3 = findHoloRenderer();
          if (holoRenderer3) {
            const showDepth = holoRenderer3.toggleDepthVisualization();
            console.log('Depth visualization:', showDepth ? 'ON (show depth)' : 'OFF (show RGB)');
          }
          break;
        case 'KeyL':
          // Toggle LDI mode (mesh vs raytracing)
          const holoRenderer4 = findHoloRenderer();
          if (holoRenderer4) {
            const currentMode = holoRenderer4.getRenderMode();
            const newMode = currentMode === 'mesh' ? 'raytracing' : 'mesh';
            holoRenderer4.setRenderMode(newMode);
            console.log('Render mode:', newMode.toUpperCase());
          }
          break;
        case 'KeyX':
          // Toggle texture debug view
          const debugPanel = document.getElementById('texture-debug');
          if (debugPanel.style.display === 'none') {
            showTextureDebug();
          } else {
            debugPanel.style.display = 'none';
          }
          break;
        case 'KeyO':
          // Toggle orbit marker visibility
          toggleHitMarker();
          if (isOrbitMode) {
            updateControls('orbit'); // Update controls display to show new status
          }
          break;
        case 'ArrowLeft':
          // Previous view
          if (loadedProjectors.length > 1) {
            const viewSelect = document.getElementById('view-select');
            const currentIndex = parseInt(viewSelect.value);
            const newIndex = (currentIndex - 1 + loadedProjectors.length) % loadedProjectors.length;
            viewSelect.value = newIndex.toString();
            viewSelect.dispatchEvent(new Event('change'));
          }
          break;
        case 'ArrowRight':
          // Next view
          if (loadedProjectors.length > 1) {
            const viewSelect = document.getElementById('view-select');
            const currentIndex = parseInt(viewSelect.value);
            const newIndex = (currentIndex + 1) % loadedProjectors.length;
            viewSelect.value = newIndex.toString();
            viewSelect.dispatchEvent(new Event('change'));
          }
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.forward = false; break;
        case 'KeyS': moveState.backward = false; break;
        case 'KeyA': moveState.left = false; break;
        case 'KeyD': moveState.right = false; break;
        case 'KeyE': moveState.up = false; break;
        case 'KeyQ': moveState.down = false; break;
      }
    });

    // Gradient threshold slider
    const gradientSlider = document.getElementById('gradient-slider');
    const gradientValue = document.getElementById('gradient-value');
    const gradientEnabled = document.getElementById('gradient-enabled');
    const invZRange = 0.09 - 0.0001; // invZMin - invZMax

    // Set initial gradient threshold to 10% of range
    const initialThreshold = invZRange * 0.10;

    // Wait for renderer to be injected, then set initial settings
    setTimeout(() => {
      const holoRenderer = findHoloRenderer();
      if (holoRenderer) {
        holoRenderer.setGradientThreshold(initialThreshold);
        // Renderer starts in mesh mode by default
      }
    }, 100);

    gradientSlider.addEventListener('input', (e) => {
      const holoRenderer = findHoloRenderer();
      if (holoRenderer) {
        // Map slider value [0, 200] to [0, 20% of invZRange]
        const threshold = (parseFloat(e.target.value) / 1000.0) * invZRange;
        holoRenderer.setGradientThreshold(threshold);
        gradientValue.textContent = threshold.toFixed(4);

        // Update enabled status and visibility
        if (threshold > 0.0) {
          gradientEnabled.textContent = 'ON';
          document.getElementById('gradient-threshold-container').style.display = 'block';
        } else {
          gradientEnabled.textContent = 'OFF';
          document.getElementById('gradient-threshold-container').style.display = 'none';
        }
      }
    });

    // Raycast for double-click orbit using ray marching in projector space
    function raycastPointCloud(mouseX, mouseY) {
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
      const ray = raycaster.ray;

      // Get the active projector (could be from scene or loadedProjectors)
      const activeProjector = projector || (loadedProjectors.length > 0 ? loadedProjectors[0] : null);
      if (!activeProjector) {
        console.warn('No projector available for raycasting');
        return null;
      }

      // Use first layer's data for raycasting
      const layer = activeProjector.lifLayers && activeProjector.lifLayers.length > 0
        ? activeProjector.lifLayers[0]
        : null;

      if (!layer) {
        console.warn('No layer data available for raycasting');
        return null;
      }

      // Get projector transform
      activeProjector.updateMatrixWorld();
      const projectorMatrixInv = activeProjector.matrixWorld.clone().invert();

      // Get depth texture data from layer (fallback to projector's main texture if not available)
      const depthTexture = layer.depthTexture || activeProjector.depthTexture;
      if (!depthTexture || !depthTexture.image) {
        console.warn('Depth texture not loaded');
        return null;
      }

      // Use layer's actual dimensions
      const imgWidth = layer.width;
      const imgHeight = layer.height;

      // Create temporary canvas to read depth texture
      const canvas = document.createElement('canvas');
      canvas.width = imgWidth;
      canvas.height = imgHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(depthTexture.image, 0, 0);
      const imageData = ctx.getImageData(0, 0, imgWidth, imgHeight);

      const invZMin = layer.invDepthRange.min;
      const invZMax = layer.invDepthRange.max;
      const baseline = layer.invDepthRange.baseline || 1.0;
      const fx = layer.intrinsics.fx;
      const fy = layer.intrinsics.fy;
      const cx = layer.intrinsics.cx;
      const cy = layer.intrinsics.cy;

      // Helper function to sample depth map at pixel coordinates
      // Note: Y-flip handling depends on texture type
      // TextureLoader textures have flipY=true, CanvasTexture have flipY=false
      function sampleDepthMap(px, py) {
        if (px < 0 || px >= imgWidth || py < 0 || py >= imgHeight) return null;

        // Check if texture needs Y-flip (TextureLoader has flipY=true, CanvasTexture has flipY=false)
        const needsFlip = !(depthTexture instanceof THREE.CanvasTexture);
        const pyToUse = needsFlip ? (imgHeight - 1) - Math.floor(py) : Math.floor(py);

        const idx = (pyToUse * imgWidth + Math.floor(px)) * 4;
        const depthValue = imageData.data[idx] / 255.0;
        const invZ = invZMax + depthValue * (invZMin - invZMax);
        if (Math.abs(invZ) < 1e-8) return null;
        return baseline / invZ;
      }

      // Transform ray to projector space
      const rayOriginWorld = ray.origin.clone();
      const rayDirWorld = ray.direction.clone();
      const rayOriginProj = rayOriginWorld.applyMatrix4(projectorMatrixInv);
      const rayDirProj = rayDirWorld.transformDirection(projectorMatrixInv);

      // Ray marching in inverse depth space
      // Start at near plane (invZMin, front) and march toward far plane (invZMax, back)
      // Note: invZMin > invZMax, so we march by decreasing invZ
      let currentInvZ = invZMin;
      let stepSize = (invZMin - invZMax) / 100.0; // Initial step: 100 steps across range (positive)
      const minStepSize = (invZMin - invZMax) / 10000.0; // Precision limit
      let iterations = 0;
      const maxIterations = 200;

      while (iterations < maxIterations && Math.abs(stepSize) > Math.abs(minStepSize)) {
        iterations++;

        // Current depth along the ray
        const currentDepth = baseline / currentInvZ;

        // Ray position at this depth: rayOrigin + t * rayDir where z = -currentDepth
        // Solve: rayOrigin.z + t * rayDir.z = -currentDepth
        const t = (-currentDepth - rayOriginProj.z) / rayDirProj.z;
        const rayPos = rayOriginProj.clone().addScaledVector(rayDirProj, t);

        // Convert to pixel coordinates
        const px = (rayPos.x * fx / currentDepth) + cx - 0.5;
        const py = (rayPos.y * fy / currentDepth) + cy - 0.5;

        // Check if within image bounds
        if (px < 0 || px >= imgWidth || py < 0 || py >= imgHeight) {
          // Ray is outside image, advance toward far (decreasing invZ)
          currentInvZ -= stepSize;
          if (currentInvZ < invZMax) break; // Past far plane
          continue;
        }

        // Sample depth map at this pixel
        const surfaceDepth = sampleDepthMap(px, py);
        if (surfaceDepth === null) {
          // No valid depth, advance toward far (decreasing invZ)
          currentInvZ -= stepSize;
          if (currentInvZ < invZMax) break;
          continue;
        }

        // Compare ray depth with surface depth
        // invZMin > invZMax, so as currentInvZ decreases from min to max, currentDepth increases
        if (currentDepth < surfaceDepth) {
          // Ray is still in front of surface, keep marching toward far (decreasing invZ)
          currentInvZ -= stepSize;
          if (currentInvZ < invZMax) break; // Past far plane
        } else {
          // Ray has passed through surface, we overshot - backtrack and refine
          currentInvZ += stepSize;
          stepSize /= 2.0; // Halve step size
          currentInvZ -= stepSize; // Advance with smaller step
        }
      }

      // Final position found
      if (iterations >= maxIterations || Math.abs(stepSize) <= Math.abs(minStepSize)) {
        const finalDepth = baseline / currentInvZ;
        const t = (-finalDepth - rayOriginProj.z) / rayDirProj.z;
        const rayPosProj = rayOriginProj.clone().addScaledVector(rayDirProj, t);

        // Check if valid
        const px = (rayPosProj.x * fx / finalDepth) + cx - 0.5;
        const py = (rayPosProj.y * fy / finalDepth) + cy - 0.5;

        if (px >= 0 && px < imgWidth && py >= 0 && py < imgHeight) {
          // Transform back to world space
          const hitPointWorld = rayPosProj.applyMatrix4(activeProjector.matrixWorld);
          console.log(`Raycast converged in ${iterations} iterations at pixel (${px.toFixed(1)}, ${py.toFixed(1)})`);
          return hitPointWorld;
        }
      }

      console.log('Raycast failed to find intersection');
      return null;
    }

    // Double-click to enter orbit mode
    renderer.domElement.addEventListener('dblclick', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      const hitPoint = raycastPointCloud(mouseX, mouseY);

      if (hitPoint) {
        // Create red marker at hit point
        createHitMarker(hitPoint);

        orbitCenter.copy(hitPoint);
        orbitDistance = camera.position.distanceTo(orbitCenter);

        const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
        orbitTheta = Math.atan2(offset.x, offset.z);
        orbitPhi = Math.acos(offset.y / orbitDistance);

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        animationStartPos.copy(camera.position);
        animationStartQuat.copy(camera.quaternion);
        animationTargetPos.copy(orbitCenter).add(new THREE.Vector3(x, y, z));

        const tempCamera = new THREE.PerspectiveCamera();
        tempCamera.position.copy(animationTargetPos);
        tempCamera.lookAt(orbitCenter);
        animationTargetQuat.copy(tempCamera.quaternion);

        isAnimating = true;
        animationProgress = 0;
        isOrbitMode = true;

        document.getElementById('mode').textContent = 'Orbit Mode';
        updateControls('orbit');
      }
    });

    // Mouse controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (e.button === 0) {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        isDragging = false;
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      if (isAnimating) {
        isAnimating = false;
      }

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      if (isOrbitMode) {
        orbitTheta -= deltaX * mouseSensitivity;
        orbitPhi -= deltaY * mouseSensitivity;
        orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
        camera.lookAt(orbitCenter);
      } else {
        euler.setFromQuaternion(camera.quaternion);
        euler.y -= deltaX * mouseSensitivity;
        euler.x -= deltaY * mouseSensitivity;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        camera.quaternion.setFromEuler(euler);
      }

      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    // Mouse wheel for zoom
    renderer.domElement.addEventListener('wheel', (e) => {
      if (isOrbitMode) {
        e.preventDefault();

        if (isAnimating) {
          isAnimating = false;
        }

        const zoomSpeed = 0.001;
        orbitDistance += e.deltaY * zoomSpeed * orbitDistance;
        orbitDistance = Math.max(0.1, Math.min(1000, orbitDistance));

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
        camera.lookAt(orbitCenter);
      }
    });

    // Touch controls for mobile
    let touches = [];
    let lastTouchDistance = 0;
    let lastTouchCenter = { x: 0, y: 0 };
    let lastTapTime = 0;
    let lastTapPosition = { x: 0, y: 0 };
    let touchStartTime = 0;
    let touchStartPosition = { x: 0, y: 0 };
    let longPressTimer = null;

    renderer.domElement.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);

      if (touches.length === 1) {
        // Track for double tap and long press
        touchStartTime = Date.now();
        touchStartPosition = { x: touches[0].clientX, y: touches[0].clientY };

        // Set up long press detection (800ms)
        longPressTimer = setTimeout(() => {
          // Reset view on long press
          camera.position.set(0, 0, 0);
          camera.quaternion.set(0, 0, 0, 1);
          isOrbitMode = false;
          isAnimating = false;
          document.getElementById('mode').textContent = 'Free Camera';
          updateControls('free');
        }, 800);
      } else if (touches.length === 2) {
        // Cancel long press if second finger added
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }

        // Calculate initial distance for pinch
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);

        // Calculate center point for two-finger pan
        lastTouchCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);

      // Cancel long press on move
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      if (touches.length === 2 && !isOrbitMode && !isAnimating) {
        // Two-finger gestures in free camera mode
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);

        const currentCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };

        // Pinch to zoom (move forward/backward) - halved sensitivity
        const distanceDelta = currentDistance - lastTouchDistance;
        const zoomSpeed = 0.005;
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(forward, distanceDelta * zoomSpeed);

        // Two-finger pan for translation (up/down, left/right) - halved and inverted
        const centerDeltaX = currentCenter.x - lastTouchCenter.x;
        const centerDeltaY = currentCenter.y - lastTouchCenter.y;
        const panSpeed = 0.0025;

        const right = new THREE.Vector3(1, 0, 0);
        right.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(right, -centerDeltaX * panSpeed);

        const up = new THREE.Vector3(0, 1, 0);
        camera.position.addScaledVector(up, centerDeltaY * panSpeed);

        lastTouchDistance = currentDistance;
        lastTouchCenter = currentCenter;
      } else if (touches.length === 2 && isOrbitMode) {
        // Two-finger gestures in orbit mode - pinch zoom only
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);

        if (isAnimating) {
          isAnimating = false;
        }

        // Pinch to change orbit distance - halved sensitivity
        const distanceDelta = currentDistance - lastTouchDistance;
        const zoomSpeed = 0.005;
        orbitDistance -= distanceDelta * zoomSpeed;
        orbitDistance = Math.max(0.1, Math.min(1000, orbitDistance));

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
        camera.lookAt(orbitCenter);

        lastTouchDistance = currentDistance;
      } else if (touches.length === 1 && !isOrbitMode && !isAnimating) {
        // Single finger drag for look around (like mouse drag)
        const touch = touches[0];
        if (previousMousePosition.x !== 0) {
          const deltaX = touch.clientX - previousMousePosition.x;
          const deltaY = touch.clientY - previousMousePosition.y;

          euler.setFromQuaternion(camera.quaternion);
          euler.y -= deltaX * mouseSensitivity;
          euler.x -= deltaY * mouseSensitivity;
          euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
          camera.quaternion.setFromEuler(euler);
        }
        previousMousePosition = { x: touch.clientX, y: touch.clientY };
      } else if (touches.length === 1 && isOrbitMode) {
        // Single finger drag to rotate orbit
        const touch = touches[0];
        if (previousMousePosition.x !== 0) {
          const deltaX = touch.clientX - previousMousePosition.x;
          const deltaY = touch.clientY - previousMousePosition.y;

          if (isAnimating) {
            isAnimating = false;
          }

          const rotateSpeed = 0.005;
          orbitTheta -= deltaX * rotateSpeed;
          orbitPhi -= deltaY * rotateSpeed;
          orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));

          const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
          const y = orbitDistance * Math.cos(orbitPhi);
          const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

          camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
          camera.lookAt(orbitCenter);
        }
        previousMousePosition = { x: touch.clientX, y: touch.clientY };
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchend', (e) => {
      e.preventDefault();

      // Cancel long press timer
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      const endTime = Date.now();
      const endPosition = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };

      touches = Array.from(e.touches);

      if (touches.length < 2) {
        lastTouchDistance = 0;
      }

      if (touches.length === 0) {
        previousMousePosition = { x: 0, y: 0 };

        // Check for double tap (like double click)
        const tapDuration = endTime - touchStartTime;
        const tapDistance = Math.sqrt(
          Math.pow(endPosition.x - touchStartPosition.x, 2) +
          Math.pow(endPosition.y - touchStartPosition.y, 2)
        );
        const timeSinceLastTap = endTime - lastTapTime;
        const distanceFromLastTap = Math.sqrt(
          Math.pow(endPosition.x - lastTapPosition.x, 2) +
          Math.pow(endPosition.y - lastTapPosition.y, 2)
        );

        // It's a tap if: quick (< 300ms), minimal movement (< 10px)
        const isTap = tapDuration < 300 && tapDistance < 10;

        if (isTap && timeSinceLastTap < 300 && distanceFromLastTap < 50) {
          // Double tap detected - enter orbit mode
          const rect = renderer.domElement.getBoundingClientRect();
          const mouseX = ((endPosition.x - rect.left) / rect.width) * 2 - 1;
          const mouseY = -((endPosition.y - rect.top) / rect.height) * 2 + 1;

          const hitPoint = raycastPointCloud(mouseX, mouseY);

          if (hitPoint) {
            // Create red marker at hit point
            createHitMarker(hitPoint);

            orbitCenter.copy(hitPoint);
            orbitDistance = camera.position.distanceTo(orbitCenter);

            const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
            orbitTheta = Math.atan2(offset.x, offset.z);
            orbitPhi = Math.acos(offset.y / orbitDistance);

            const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
            const y = orbitDistance * Math.cos(orbitPhi);
            const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

            animationStartPos.copy(camera.position);
            animationStartQuat.copy(camera.quaternion);
            animationTargetPos.copy(orbitCenter).add(new THREE.Vector3(x, y, z));

            const tempCamera = new THREE.PerspectiveCamera();
            tempCamera.position.copy(animationTargetPos);
            tempCamera.lookAt(orbitCenter);
            animationTargetQuat.copy(tempCamera.quaternion);

            isAnimating = true;
            animationProgress = 0;
            isOrbitMode = true;

            document.getElementById('mode').textContent = 'Orbit Mode';
            updateControls('orbit');
          }

          // Reset for next double tap detection
          lastTapTime = 0;
          lastTapPosition = { x: 0, y: 0 };
        } else if (isTap) {
          // Single tap - record for potential double tap
          lastTapTime = endTime;
          lastTapPosition = endPosition;
        }
      }
    }, { passive: false });

    // LIF file loading handler
    document.getElementById('lif-file-input').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const statusEl = document.getElementById('lif-status');
      statusEl.textContent = 'Loading...';
      statusEl.style.color = '#ffaa00';

      try {
        // Load LIF file and create projectors
        const result = await loadLifFile(file);

        if (result.projectors.length === 0) {
          throw new Error('No views found in LIF file');
        }

        // Store all loaded projectors
        loadedProjectors = result.projectors;

        // Store stereo_render_data globally for RaycastPlane
        window.lifStereoRenderData = result.stereo_render_data;

        // Calculate orbit centers for all views
        // Note: result.orbitCenter is the orbit center for view 0, calculated in LifLoader.ts
        // For now, we only support orbit center for view 0 (first view)
        viewOrbitCenters = new Array(result.projectors.length).fill(null);

        if (result.orbitCenter) {
          // Use the properly calculated orbit center from LifLoader for view 0
          viewOrbitCenters[0] = result.orbitCenter.clone();
          console.log('View 0 orbit center from LifLoader:', result.orbitCenter);
        }

        // Remove old projector(s) from scene
        scene.remove(projector);
        // Remove any other loaded projectors from previous LIF file
        loadedProjectors.forEach(p => scene.remove(p));

        // Add ALL projectors to the scene for stereo support
        // In mono mode, we'll use view switching to control which one is active
        result.projectors.forEach((p, index) => {
          scene.add(p);
          // Add axes helper to each projector
          const axesHelper = new THREE.AxesHelper(0.5);
          p.add(axesHelper);
          // Initially hide all except the first one (for mesh rendering compatibility)
          p.visible = (index === 0);
        });

        // Use first view as the active projector
        const newProjector = result.projectors[0];

        // Update global projector reference
        window.projector = newProjector;
        projector = newProjector; // Update local reference too

        // Populate view selector dropdown if multiple views
        const viewSelect = document.getElementById('view-select');
        const viewSelector = document.getElementById('view-selector');
        viewSelect.innerHTML = '';

        for (let i = 0; i < result.projectors.length; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = `View ${i}`;
          viewSelect.appendChild(option);
        }

        // Show view selector if multiple views
        if (result.projectors.length > 1) {
          viewSelector.style.display = 'block';
        } else {
          viewSelector.style.display = 'none';
        }

        // Update point count display
        const pointCount = newProjector.width * newProjector.height;
        document.getElementById('point-count').textContent = pointCount.toLocaleString();

        // Position camera at the projector's location (view pose)
        camera.position.copy(newProjector.position);
        camera.quaternion.copy(newProjector.quaternion);

        // Store as new initial position for reset
        initialCameraPosition.copy(newProjector.position);
        initialCameraQuaternion.copy(newProjector.quaternion);

        // Check if we should start in orbit mode
        if (result.orbitCenter) {
          // Store initial orbit state
          initialOrbitCenter = result.orbitCenter.clone();
          initialHasOrbitMode = true;

          // Create red marker at orbit center
          createHitMarker(result.orbitCenter);

          // Set up orbit mode
          orbitCenter.copy(result.orbitCenter);
          orbitDistance = camera.position.distanceTo(orbitCenter);

          const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
          orbitTheta = Math.atan2(offset.x, offset.z);
          orbitPhi = Math.acos(offset.y / orbitDistance);

          const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
          const y = orbitDistance * Math.cos(orbitPhi);
          const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

          animationStartPos.copy(camera.position);
          animationStartQuat.copy(camera.quaternion);
          animationTargetPos.copy(orbitCenter).add(new THREE.Vector3(x, y, z));

          const tempCamera = new THREE.PerspectiveCamera();
          tempCamera.position.copy(animationTargetPos);
          tempCamera.lookAt(orbitCenter);
          animationTargetQuat.copy(tempCamera.quaternion);

          isAnimating = true;
          animationProgress = 0;
          isOrbitMode = true;

          document.getElementById('mode').textContent = 'Orbit Mode (auto)';
          updateControls('orbit');

          console.log('Auto-orbit mode enabled with convergence point:', orbitCenter);
        } else {
          // No orbit center, clear orbit state
          initialOrbitCenter = null;
          initialHasOrbitMode = false;

          isOrbitMode = false;
          isAnimating = false;
          document.getElementById('mode').textContent = 'Free Camera';
          updateControls('free');

          console.log('No orbit center from stereo_render_data, starting in free camera mode');
        }

        console.log('Camera positioned at view location:', camera.position, camera.quaternion);
        console.log('Stored as initial position for reset (R key)');

        statusEl.textContent = `Loaded: ${newProjector.width}x${newProjector.height} (${result.projectors.length} view${result.projectors.length > 1 ? 's' : ''})`;
        statusEl.style.color = '#00ff00';

        // Helper function to update view info display
        function updateViewInfo(proj) {
          document.getElementById('view-info').style.display = 'block';

          // Projector Pose
          document.getElementById('view-pos').textContent =
            `(${proj.position.x.toFixed(4)}, ${proj.position.y.toFixed(4)}, ${proj.position.z.toFixed(4)})`;
          const quat = proj.quaternion;
          document.getElementById('view-rot').textContent =
            `(${quat.x.toFixed(3)}, ${quat.y.toFixed(3)}, ${quat.z.toFixed(3)}, ${quat.w.toFixed(3)})`;

          // Main View (projector's main intrinsics)
          document.getElementById('main-width').textContent = proj.width;
          document.getElementById('main-height').textContent = proj.height;
          const mainFocal = proj.intrinsics.fx;
          document.getElementById('main-focal').textContent = mainFocal.toFixed(2);

          // Layer 0 (if available)
          if (proj.lifLayers && proj.lifLayers.length > 0) {
            const layer0 = proj.lifLayers[0];
            document.getElementById('layer0-width').textContent = layer0.width;
            document.getElementById('layer0-height').textContent = layer0.height;
            document.getElementById('layer0-focal').textContent = layer0.intrinsics.fx.toFixed(2);
          } else {
            document.getElementById('layer0-width').textContent = '-';
            document.getElementById('layer0-height').textContent = '-';
            document.getElementById('layer0-focal').textContent = '-';
          }

          // Depth Range (using main view invDepthRange)
          document.getElementById('view-invz-min').textContent = proj.invDepthRange.min.toFixed(6);
          document.getElementById('view-invz-max').textContent = proj.invDepthRange.max.toFixed(6);
          const baseline_mm = (proj.invDepthRange.baseline || 1.0) * 1000; // Convert to mm
          document.getElementById('view-baseline').textContent = baseline_mm.toFixed(2);
        }

        // Update view info for first view
        updateViewInfo(newProjector);

        console.log('LIF file loaded successfully');
        console.log('  Views:', result.projectors.length);
        console.log('  Dimensions:', newProjector.width, 'x', newProjector.height);
        console.log('  Position:', newProjector.position);
        console.log('  Rotation (quaternion):', newProjector.quaternion);

      } catch (error) {
        console.error('Failed to load LIF file:', error);
        statusEl.textContent = 'Error: ' + error.message;
        statusEl.style.color = '#ff0000';
      }
    });

    // View selector change handler
    document.getElementById('view-select').addEventListener('change', async (e) => {
      const viewIndex = parseInt(e.target.value);

      if (viewIndex >= 0 && viewIndex < loadedProjectors.length) {
        const selectedProjector = loadedProjectors[viewIndex];

        // Wait for the projector to be fully initialized (textures loaded)
        await selectedProjector.initialized;

        // Update RaycastPlane with new projector data FIRST (if in raycast mode and mono)
        // This ensures textures are loaded before we switch visibility
        const holoRenderer = findHoloRenderer();
        if (holoRenderer && holoRenderer.getRenderMode() === 'raytracing') {
          // Only update projector data in mono mode (stereo uses all projectors)
          if (holoRenderer.raycastPlane && holoRenderer.raycastPlane.getViewMode() === 'mono') {
            await holoRenderer.raycastPlane.updateProjectorData(selectedProjector);
            console.log('Updated RaycastPlane with new projector textures');
          }
        }

        // Hide old projector, show new one (they're both in the scene for stereo support)
        projector.visible = false;
        selectedProjector.visible = true;

        // Update global reference
        window.projector = selectedProjector;
        projector = selectedProjector;

        // Update initial position for reset (but don't move camera yet)
        initialCameraPosition.copy(selectedProjector.position);
        initialCameraQuaternion.copy(selectedProjector.quaternion);

        // Update initial orbit state for this view
        if (viewOrbitCenters[viewIndex]) {
          initialOrbitCenter = viewOrbitCenters[viewIndex].clone();
          initialHasOrbitMode = true;
        } else {
          initialOrbitCenter = null;
          initialHasOrbitMode = false;
        }

        // Update view info display
        document.getElementById('view-pos').textContent =
          `(${selectedProjector.position.x.toFixed(4)}, ${selectedProjector.position.y.toFixed(4)}, ${selectedProjector.position.z.toFixed(4)})`;

        const quat = selectedProjector.quaternion;
        document.getElementById('view-rot').textContent =
          `(${quat.x.toFixed(3)}, ${quat.y.toFixed(3)}, ${quat.z.toFixed(3)}, ${quat.w.toFixed(3)})`;

        document.getElementById('view-invz-min').textContent = selectedProjector.invDepthRange.min.toFixed(6);
        document.getElementById('view-invz-max').textContent = selectedProjector.invDepthRange.max.toFixed(6);
        const baseline_mm = (selectedProjector.invDepthRange.baseline || 1.0) * 1000;
        document.getElementById('view-baseline').textContent = baseline_mm.toFixed(2);

        // Update point count
        const pointCount = selectedProjector.width * selectedProjector.height;
        document.getElementById('point-count').textContent = pointCount.toLocaleString();

        console.log(`Switched to view ${viewIndex}`);
      }
    });

    // WebXR Session Management
    let xrSession = null;
    let xrRefSpace = null;
    let controller1 = null;
    let controller2 = null;
    let controllerGrip1 = null;
    let controllerGrip2 = null;

    // Check for XR support and show button if available
    async function setupXR() {
      if (!navigator.xr) {
        console.log('WebXR not supported in this browser');
        return;
      }

      try {
        const supported = await navigator.xr.isSessionSupported('immersive-vr');
        if (supported) {
          document.getElementById('xr-container').style.display = 'block';
          console.log('WebXR VR mode supported!');
        } else {
          console.log('Immersive VR not supported');
        }
      } catch (err) {
        console.error('Error checking XR support:', err);
      }
    }

    // Start XR session
    async function startXRSession() {
      if (!navigator.xr) return;

      try {
        // Request immersive-vr session with no required features (for maximum compatibility)
        xrSession = await navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local', 'local-floor', 'hand-tracking', 'layers']
        });

        // Set up XR rendering
        await renderer.xr.setSession(xrSession);

        // Try to get reference space with fallback chain
        try {
          xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
          console.log('Using local-floor reference space');
        } catch (e) {
          try {
            xrRefSpace = await xrSession.requestReferenceSpace('local');
            console.log('Using local reference space');
          } catch (e2) {
            xrRefSpace = await xrSession.requestReferenceSpace('viewer');
            console.log('Using viewer reference space (fallback)');
          }
        }

        // Setup XR controllers
        setupControllers();

        // Hide axes helpers in VR mode
        scene.traverse((obj) => {
          if (obj instanceof THREE.AxesHelper) {
            obj.visible = false;
          }
        });

        // Desktop raycast plane is automatically hidden in VR mode via layer system
        // (desktop plane is on layer 3, VR cameras only see layers 0, 1, 2)
        const holoRenderer = findHoloRenderer();
        if (holoRenderer && holoRenderer.raycastPlane) {
          console.log('Desktop raycast plane hidden via layer system (layer 3)');
        }

        // Hide orbit marker in VR mode
        if (hitMarker) {
          hitMarker.visible = false;
          console.log('Orbit marker hidden for VR mode');
        }

        // Update button state
        const xrButton = document.getElementById('xr-button');
        const xrStatus = document.getElementById('xr-status');
        xrButton.textContent = 'Exit VR';
        xrButton.style.background = '#ff4444';
        xrStatus.textContent = 'In VR Session';
        xrStatus.style.color = '#00ff00';

        // Handle session end
        xrSession.addEventListener('end', () => {
          cleanupControllers();

          // Clean up XR raycast planes
          const holoRenderer = findHoloRenderer();
          if (holoRenderer) {
            holoRenderer.cleanupXR();

            // Desktop raycast plane automatically visible via layer system
            // (desktop camera sees all layers including layer 3)
            if (holoRenderer.raycastPlane) {
              console.log('Desktop raycast plane restored via layer system');
            }
          }

          // Restore orbit marker visibility (if it was visible before)
          if (hitMarker && hitMarkerVisible) {
            hitMarker.visible = true;
            console.log('Orbit marker restored');
          }

          // Show axes helpers again when exiting VR
          scene.traverse((obj) => {
            if (obj instanceof THREE.AxesHelper) {
              obj.visible = true;
            }
          });

          xrSession = null;
          xrRefSpace = null;
          xrButton.textContent = 'Enter VR';
          xrButton.style.background = '#0066ff';
          xrStatus.textContent = 'XR Ready';
          xrStatus.style.color = '#aaa';
          console.log('XR session ended');
        });

        console.log('XR session started successfully');
      } catch (err) {
        console.error('Error starting XR session:', err);
        document.getElementById('xr-status').textContent = 'Error: ' + err.message;
        document.getElementById('xr-status').style.color = '#ff4444';
      }
    }

    // End XR session
    async function endXRSession() {
      if (xrSession) {
        await xrSession.end();
      }
    }

    // XR button click handler
    document.getElementById('xr-button').addEventListener('click', () => {
      if (xrSession) {
        endXRSession();
      } else {
        startXRSession();
      }
    });

    // Initialize XR support check
    setupXR();

    // XR Controller Setup
    function setupControllers() {
      const controllerModelFactory = new XRControllerModelFactory();

      // Controller 1 (usually right hand)
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      controller1.addEventListener('select', onSelect);
      scene.add(controller1);

      // Controller 2 (usually left hand)
      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      controller2.addEventListener('select', onSelect);
      scene.add(controller2);

      // Add visual ray to controllers
      const geometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -1)
      ]);
      const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });

      const line1 = new THREE.Line(geometry, material);
      line1.name = 'ray';
      line1.scale.z = 5; // Ray length
      controller1.add(line1.clone());

      const line2 = new THREE.Line(geometry, material);
      line2.name = 'ray';
      line2.scale.z = 5;
      controller2.add(line2.clone());

      // Add controller grips with full 3D models
      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      console.log('XR controllers initialized with full 3D models');
    }

    // Cleanup controllers on session end
    function cleanupControllers() {
      if (controller1) {
        controller1.removeEventListener('selectstart', onSelectStart);
        controller1.removeEventListener('selectend', onSelectEnd);
        controller1.removeEventListener('select', onSelect);
        scene.remove(controller1);
        controller1 = null;
      }

      if (controller2) {
        controller2.removeEventListener('selectstart', onSelectStart);
        controller2.removeEventListener('selectend', onSelectEnd);
        controller2.removeEventListener('select', onSelect);
        scene.remove(controller2);
        controller2 = null;
      }

      if (controllerGrip1) {
        scene.remove(controllerGrip1);
        controllerGrip1 = null;
      }

      if (controllerGrip2) {
        scene.remove(controllerGrip2);
        controllerGrip2 = null;
      }
    }

    // Controller event handlers
    function onSelectStart(event) {
      const controller = event.target;
      controller.userData.isSelecting = true;
      console.log('Controller select start');
    }

    function onSelectEnd(event) {
      const controller = event.target;
      controller.userData.isSelecting = false;
      console.log('Controller select end');
    }

    async function onSelect(event) {
      const controller = event.target;
      const holoRenderer = findHoloRenderer();

      if (!holoRenderer || !holoRenderer.raycastPlane) {
        console.log('No raycast plane available in XR');
        return;
      }

      // Toggle mono/stereo mode with trigger
      const currentMode = holoRenderer.raycastPlane.getViewMode();
      const projectorCount = holoRenderer.raycastPlane.getProjectorCount();

      if (currentMode === 'mono' && projectorCount >= 2) {
        await holoRenderer.raycastPlane.toggleViewMode();
        console.log('XR: Switched to STEREO mode');
      } else if (currentMode === 'stereo') {
        await holoRenderer.raycastPlane.toggleViewMode();
        console.log('XR: Switched to MONO mode');
      }
    }

    // Animation loop
    let lastTime = 0;
    let frameCount = 0;
    let fpsFrameCount = 0;
    let fpsUpdateTime = 0;

    renderer.setAnimationLoop((time) => {
      const deltaTime = (time - lastTime) / 1000;
      lastTime = time;
      frameCount++;
      fpsFrameCount++;

      // XR camera height tracking - set projector Y once when XR camera is first available
      if (renderer.xr.isPresenting && initialY === null) {
        try {
          const xrCam = renderer.xr.getCamera(camera);

          // Check if XR cameras are available
          if (xrCam.cameras && xrCam.cameras.length >= 2) {
            const leftCam = xrCam.cameras[0];
            const rightCam = xrCam.cameras[1];

            const candidateY = (leftCam.position.y + rightCam.position.y) / 2;

            // Only accept if above threshold (retry until we get valid reading)
            if (candidateY > INITIAL_Y_MIN_THRESHOLD) {
              initialY = candidateY;
              console.log('Initial Y position set to:', initialY.toFixed(3), 'm');

              // Set all projectors Y position to this initial Y (only once)
              if (projector) {
                projector.position.y = initialY;
              }

              loadedProjectors.forEach(p => {
                p.position.y = initialY;
              });
            } else {
              console.log('InitialY candidate', candidateY.toFixed(3), 'm too low, retrying...');
            }
          }
        } catch (err) {
          // Silently ignore errors during XR camera access
        }
      }

      // Update FPS counter and camera position
      if (time - fpsUpdateTime >= 500) {
        const fps = Math.round((fpsFrameCount * 1000) / (time - fpsUpdateTime));
        document.getElementById('fps').textContent = fps;
        fpsFrameCount = 0;
        fpsUpdateTime = time;

        // Update camera position display
        const pos = camera.position;
        document.getElementById('camera-pos').textContent =
          `(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`;

        // Update camera forward vector
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(camera.quaternion);
        document.getElementById('camera-forward').textContent =
          `(${forward.x.toFixed(3)}, ${forward.y.toFixed(3)}, ${forward.z.toFixed(3)})`;

        // Update orbit center display if in orbit mode
        if (isOrbitMode) {
          const orbitCenterPos = document.getElementById('orbit-center-pos');
          orbitCenterPos.textContent = `(${orbitCenter.x.toFixed(3)}, ${orbitCenter.y.toFixed(3)}, ${orbitCenter.z.toFixed(3)})`;
        }
      }

      // Camera animation
      if (isAnimating) {
        animationProgress += deltaTime / animationDuration;

        if (animationProgress >= 1.0) {
          animationProgress = 1.0;
          isAnimating = false;
        }

        const t = animationProgress < 0.5
          ? 2 * animationProgress * animationProgress
          : 1 - Math.pow(-2 * animationProgress + 2, 2) / 2;

        camera.position.lerpVectors(animationStartPos, animationTargetPos, t);
        camera.quaternion.slerpQuaternions(animationStartQuat, animationTargetQuat, t);
      }

      // WASD movement
      if (!isOrbitMode && !isAnimating) {
        const moveVector = new THREE.Vector3();
        if (moveState.forward) moveVector.z -= 1;
        if (moveState.backward) moveVector.z += 1;
        if (moveState.left) moveVector.x -= 1;
        if (moveState.right) moveVector.x += 1;
        if (moveState.up) moveVector.y += 1;
        if (moveState.down) moveVector.y -= 1;

        if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          moveVector.applyQuaternion(camera.quaternion);
          moveVector.multiplyScalar(moveSpeed * deltaTime);
          camera.position.add(moveVector);
        }
      }

      renderer.render(scene, camera);
    });
  </script>
</body>

</html>
