<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LIF Renderer Demo</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 5px;
      z-index: 100;
    }
  </style>
</head>

<body>
  <div id="info">
    LIF Renderer Demo<br>
    FPS: <span id="fps">60</span><br>
    Points: <span id="point-count">0</span><br>
    Mode: <span id="mode">Free Camera</span><br>
    <span id="camera-pos">(0.000, 0.000, 0.000)</span><br>
    <div style="margin-top: 10px;">
      Gradient Filter: <span id="gradient-enabled">ON</span><br>
      <div id="gradient-threshold-container">
        Threshold: <span id="gradient-value">0.0090</span><br>
        <input type="range" id="gradient-slider" min="0" max="200" value="100" step="1" style="width: 200px;">
      </div>
    </div>
    <span id="controls"></span>
  </div>

  <div id="lif-loader" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 5px; color: white; font-family: monospace; z-index: 100; max-width: 300px;">
    <div style="margin-bottom: 8px;">Load LIF File:</div>
    <input type="file" id="lif-file-input" accept=".lif,.jpg,.jpeg,image/jpeg" style="width: 200px;">
    <div id="lif-status" style="margin-top: 8px; font-size: 12px; color: #aaa;">LIF = JPEG with metadata</div>

    <div id="view-selector" style="margin-top: 10px; display: none;">
      <label style="font-size: 12px;">
        View:
        <select id="view-select" style="margin-left: 5px; background: #333; color: white; border: 1px solid #555; padding: 2px 5px;">
          <option value="0">View 0</option>
        </select>
      </label>
    </div>

    <div id="view-info" style="margin-top: 15px; font-size: 11px; line-height: 1.4; border-top: 1px solid #555; padding-top: 10px; display: none;">
      <div style="font-weight: bold; margin-bottom: 5px;">View Info:</div>
      <div>Pos: <span id="view-pos">-</span></div>
      <div>Rot: <span id="view-rot">-</span></div>
      <div style="margin-top: 5px;">fx: <span id="view-fx">-</span></div>
      <div>fy: <span id="view-fy">-</span></div>
      <div>cx: <span id="view-cx">-</span></div>
      <div>cy: <span id="view-cy">-</span></div>
      <div style="margin-top: 5px;">invZ min: <span id="view-invz-min">-</span></div>
      <div>invZ max: <span id="view-invz-max">-</span></div>
      <div>baseline: <span id="view-baseline">-</span>m</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.js";
    import { HoloProjector, HoloRenderer, loadLifFile } from "./src/index.ts";

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.0001,
      5000
    );
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x111111);
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Match monitor color space
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // SFMoMA restaurant scene data
    const fullWidth = 1280;
    const fullHeight = 800;
    const width = fullWidth;
    const height = fullHeight;

    document.getElementById('point-count').textContent = (width * height).toLocaleString();

    // Create holographic projector (use let so we can replace it when loading LIF files)
    let projector = new HoloProjector({
      rgbUrl: './assets/rgb.jpg',
      depthUrl: './assets/depth.png',
      intrinsics: {
        fx: 0.78 * fullWidth,
        fy: 0.78 * fullWidth,
        cx: width / 2,
        cy: height / 2,
      },
      invDepthRange: {
        min: 0.09,
        max: 0.0001,
        baseline: 0.045,
      },
      width,
      height,
      onLoad: () => console.log('Projector loaded!')
    });

    scene.add(projector);

    // Store initial camera position and rotation for reset
    let initialCameraPosition = new THREE.Vector3(0, 0, 0);
    let initialCameraQuaternion = new THREE.Quaternion(0, 0, 0, 1);

    // Store all loaded projectors from LIF file
    let loadedProjectors = [];

    // Add helpers
    const axesHelper = new THREE.AxesHelper(0.5);
    projector.add(axesHelper);

    // Helper function to find HoloRenderer in scene
    function findHoloRenderer() {
      let renderer = null;
      scene.traverse((obj) => {
        if (obj instanceof HoloRenderer) {
          renderer = obj;
        }
      });
      return renderer;
    }

    // Camera controls
    const moveState = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      up: false,
      down: false,
    };

    const mouseSensitivity = 0.002;
    const moveSpeed = 2.0;
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');

    // Orbit mode state
    let isOrbitMode = false;
    let orbitCenter = new THREE.Vector3();
    let orbitDistance = 5.0;
    let orbitPhi = 0;
    let orbitTheta = 0;

    // Raycast hit marker (red sphere)
    let hitMarker = null;
    let hitMarkerVisible = true; // Default to visible
    function createHitMarker(position) {
      // Remove old marker if exists
      if (hitMarker) {
        scene.remove(hitMarker);
      }

      // Create red sphere at hit point
      const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      hitMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      hitMarker.position.copy(position);
      hitMarker.visible = hitMarkerVisible;
      scene.add(hitMarker);
    }

    function toggleHitMarker() {
      if (hitMarker) {
        hitMarkerVisible = !hitMarkerVisible;
        hitMarker.visible = hitMarkerVisible;
        console.log('Orbit marker:', hitMarkerVisible ? 'visible' : 'hidden');
      }
    }

    // Camera animation state
    let isAnimating = false;
    let animationProgress = 0;
    let animationStartPos = new THREE.Vector3();
    let animationStartQuat = new THREE.Quaternion();
    let animationTargetPos = new THREE.Vector3();
    let animationTargetQuat = new THREE.Quaternion();
    const animationDuration = 0.5;

    // Detect device type and set controls text
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                     ('ontouchstart' in window) ||
                     (navigator.maxTouchPoints > 0);

    const controlsElement = document.getElementById('controls');

    // Function to update controls based on mode
    function updateControls(mode) {
      if (mode === 'free') {
        if (isMobile) {
          controlsElement.innerHTML =
            'Touch: Look around<br>' +
            'Double Tap: Orbit point<br>' +
            '2 Fingers: Pan/Zoom<br>' +
            'Long Press: Reset view';
        } else {
          const viewNavigation = loadedProjectors.length > 1 ? '←→: Switch views<br>' : '';
          controlsElement.innerHTML =
            'WASD+QE: Move camera<br>' +
            'Click+Drag: Look around<br>' +
            'Double Click: Orbit point<br>' +
            viewNavigation +
            'R: Reset view<br>' +
            'M: Toggle mesh mode<br>' +
            'V: Toggle depth view<br>' +
            'G: Toggle gradient filter<br>' +
            'F: Toggle frustum';
        }
      } else if (mode === 'orbit') {
        if (isMobile) {
          controlsElement.innerHTML =
            'Touch: Rotate orbit<br>' +
            'Pinch: Zoom<br>' +
            'Long Press: Reset view';
        } else {
          const viewNavigation = loadedProjectors.length > 1 ? '←→: Switch views<br>' : '';
          const markerStatus = hitMarker ? (hitMarkerVisible ? 'ON' : 'OFF') : 'N/A';
          controlsElement.innerHTML =
            'Click+Drag: Rotate orbit<br>' +
            'Wheel: Zoom<br>' +
            viewNavigation +
            'O: Toggle orbit marker (' + markerStatus + ')<br>' +
            'R: Reset view<br>' +
            'Escape: Exit orbit mode';
        }
      }
    }

    // Set initial controls for free camera mode
    updateControls('free');

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.forward = true; break;
        case 'KeyS': moveState.backward = true; break;
        case 'KeyA': moveState.left = true; break;
        case 'KeyD': moveState.right = true; break;
        case 'KeyE': moveState.up = true; break;
        case 'KeyQ': moveState.down = true; break;
        case 'Escape':
          if (isOrbitMode) {
            isOrbitMode = false;
            isAnimating = false;
            document.getElementById('mode').textContent = 'Free Camera';
            updateControls('free');
          }
          break;
        case 'KeyF':
          projector.frustumHelper.visible = !projector.frustumHelper.visible;
          break;
        case 'KeyR':
          // Reset view to initial position
          camera.position.copy(initialCameraPosition);
          camera.quaternion.copy(initialCameraQuaternion);
          isOrbitMode = false;
          isAnimating = false;
          document.getElementById('mode').textContent = 'Free Camera';
          updateControls('free');
          break;
        case 'KeyM':
          // Cycle mesh mode
          const holoRenderer = findHoloRenderer();
          if (holoRenderer) {
            const meshMode = holoRenderer.cycleMeshMode();
            const modeNames = ['Billboard', 'Connected Mesh'];
            console.log('Mesh mode:', modeNames[meshMode]);
          }
          break;
        case 'KeyG':
          // Toggle gradient filter
          const holoRenderer2 = findHoloRenderer();
          if (holoRenderer2) {
            const currentThreshold = holoRenderer2.getGradientThreshold();
            const invZRange = 0.09 - 0.0001;
            const defaultThreshold = invZRange * 0.10;

            if (currentThreshold > 0.0) {
              // Turn off
              holoRenderer2.setGradientThreshold(0.0);
              document.getElementById('gradient-enabled').textContent = 'OFF';
              document.getElementById('gradient-threshold-container').style.display = 'none';
              console.log('Gradient filter: OFF');
            } else {
              // Turn on with default threshold
              holoRenderer2.setGradientThreshold(defaultThreshold);
              document.getElementById('gradient-enabled').textContent = 'ON';
              document.getElementById('gradient-threshold-container').style.display = 'block';
              document.getElementById('gradient-value').textContent = defaultThreshold.toFixed(4);
              document.getElementById('gradient-slider').value = '100';
              console.log('Gradient filter: ON');
            }
          }
          break;
        case 'KeyV':
          // Toggle depth visualization
          const holoRenderer3 = findHoloRenderer();
          if (holoRenderer3) {
            const showDepth = holoRenderer3.toggleDepthVisualization();
            console.log('Depth visualization:', showDepth ? 'ON (show depth)' : 'OFF (show RGB)');
          }
          break;
        case 'KeyO':
          // Toggle orbit marker visibility
          toggleHitMarker();
          if (isOrbitMode) {
            updateControls('orbit'); // Update controls display to show new status
          }
          break;
        case 'ArrowLeft':
          // Previous view
          if (loadedProjectors.length > 1) {
            const viewSelect = document.getElementById('view-select');
            const currentIndex = parseInt(viewSelect.value);
            const newIndex = (currentIndex - 1 + loadedProjectors.length) % loadedProjectors.length;
            viewSelect.value = newIndex.toString();
            viewSelect.dispatchEvent(new Event('change'));
          }
          break;
        case 'ArrowRight':
          // Next view
          if (loadedProjectors.length > 1) {
            const viewSelect = document.getElementById('view-select');
            const currentIndex = parseInt(viewSelect.value);
            const newIndex = (currentIndex + 1) % loadedProjectors.length;
            viewSelect.value = newIndex.toString();
            viewSelect.dispatchEvent(new Event('change'));
          }
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.forward = false; break;
        case 'KeyS': moveState.backward = false; break;
        case 'KeyA': moveState.left = false; break;
        case 'KeyD': moveState.right = false; break;
        case 'KeyE': moveState.up = false; break;
        case 'KeyQ': moveState.down = false; break;
      }
    });

    // Gradient threshold slider
    const gradientSlider = document.getElementById('gradient-slider');
    const gradientValue = document.getElementById('gradient-value');
    const gradientEnabled = document.getElementById('gradient-enabled');
    const invZRange = 0.09 - 0.0001; // invZMin - invZMax

    // Set initial gradient threshold to 10% of range
    const initialThreshold = invZRange * 0.10;

    // Wait for renderer to be injected, then set initial settings
    setTimeout(() => {
      const holoRenderer = findHoloRenderer();
      if (holoRenderer) {
        holoRenderer.setGradientThreshold(initialThreshold);
        holoRenderer.setMeshMode(1); // Start in mesh mode
      }
    }, 100);

    gradientSlider.addEventListener('input', (e) => {
      const holoRenderer = findHoloRenderer();
      if (holoRenderer) {
        // Map slider value [0, 200] to [0, 20% of invZRange]
        const threshold = (parseFloat(e.target.value) / 1000.0) * invZRange;
        holoRenderer.setGradientThreshold(threshold);
        gradientValue.textContent = threshold.toFixed(4);

        // Update enabled status and visibility
        if (threshold > 0.0) {
          gradientEnabled.textContent = 'ON';
          document.getElementById('gradient-threshold-container').style.display = 'block';
        } else {
          gradientEnabled.textContent = 'OFF';
          document.getElementById('gradient-threshold-container').style.display = 'none';
        }
      }
    });

    // Raycast for double-click orbit using ray marching in projector space
    function raycastPointCloud(mouseX, mouseY) {
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
      const ray = raycaster.ray;

      // Get projector transform
      projector.updateMatrixWorld();
      const projectorMatrixInv = projector.matrixWorld.clone().invert();

      // Get depth texture data
      const depthTexture = projector.depthTexture;
      if (!depthTexture || !depthTexture.image) {
        console.warn('Depth texture not loaded');
        return null;
      }

      // Use projector's actual dimensions, not global width/height
      const imgWidth = projector.width;
      const imgHeight = projector.height;

      // Create temporary canvas to read depth texture
      const canvas = document.createElement('canvas');
      canvas.width = imgWidth;
      canvas.height = imgHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(depthTexture.image, 0, 0);
      const imageData = ctx.getImageData(0, 0, imgWidth, imgHeight);

      const invZMin = projector.invDepthRange.min;
      const invZMax = projector.invDepthRange.max;
      const baseline = projector.invDepthRange.baseline || 1.0;
      const fx = projector.intrinsics.fx;
      const fy = projector.intrinsics.fy;
      const cx = projector.intrinsics.cx;
      const cy = projector.intrinsics.cy;

      // Helper function to sample depth map at pixel coordinates
      // Note: Y-flip handling - THREE.js textures have flipY=true by default
      function sampleDepthMap(px, py) {
        if (px < 0 || px >= imgWidth || py < 0 || py >= imgHeight) return null;
        // Flip Y coordinate to match texture coordinate system
        const pyFlipped = (imgHeight - 1) - Math.floor(py);
        const idx = (pyFlipped * imgWidth + Math.floor(px)) * 4;
        const depthValue = imageData.data[idx] / 255.0;
        const invZ = invZMax + depthValue * (invZMin - invZMax);
        if (Math.abs(invZ) < 1e-8) return null;
        return baseline / invZ;
      }

      // Transform ray to projector space
      const rayOriginWorld = ray.origin.clone();
      const rayDirWorld = ray.direction.clone();
      const rayOriginProj = rayOriginWorld.applyMatrix4(projectorMatrixInv);
      const rayDirProj = rayDirWorld.transformDirection(projectorMatrixInv);

      // Ray marching in inverse depth space
      // Start at far plane (invZMax) and march toward near plane (invZMin)
      let currentInvZ = invZMax;
      let stepSize = (invZMin - invZMax) / 100.0; // Initial step: 100 steps across range
      const minStepSize = (invZMin - invZMax) / 10000.0; // Precision limit
      let iterations = 0;
      const maxIterations = 200;

      while (iterations < maxIterations && Math.abs(stepSize) > Math.abs(minStepSize)) {
        iterations++;

        // Current depth along the ray
        const currentDepth = baseline / currentInvZ;

        // Ray position at this depth: rayOrigin + t * rayDir where z = -currentDepth
        // Solve: rayOrigin.z + t * rayDir.z = -currentDepth
        const t = (-currentDepth - rayOriginProj.z) / rayDirProj.z;
        const rayPos = rayOriginProj.clone().addScaledVector(rayDirProj, t);

        // Convert to pixel coordinates
        const px = (rayPos.x * fx / currentDepth) + cx - 0.5;
        const py = (rayPos.y * fy / currentDepth) + cy - 0.5;

        // Check if within image bounds
        if (px < 0 || px >= imgWidth || py < 0 || py >= imgHeight) {
          // Ray is outside image, advance
          currentInvZ += stepSize;
          if (currentInvZ > invZMin) break; // Past near plane
          continue;
        }

        // Sample depth map at this pixel
        const surfaceDepth = sampleDepthMap(px, py);
        if (surfaceDepth === null) {
          // No valid depth, advance
          currentInvZ += stepSize;
          if (currentInvZ > invZMin) break;
          continue;
        }

        // Compare ray depth with surface depth
        if (currentDepth > surfaceDepth) {
          // Ray is behind surface, keep marching forward (increasing invZ)
          currentInvZ += stepSize;
          if (currentInvZ > invZMin) break; // Past near plane
        } else {
          // Ray is in front of surface, we overshot - backtrack and refine
          currentInvZ -= stepSize;
          stepSize /= 2.0; // Halve step size
          currentInvZ += stepSize; // Advance with smaller step
        }
      }

      // Final position found
      if (iterations >= maxIterations || Math.abs(stepSize) <= Math.abs(minStepSize)) {
        const finalDepth = baseline / currentInvZ;
        const t = (-finalDepth - rayOriginProj.z) / rayDirProj.z;
        const rayPosProj = rayOriginProj.clone().addScaledVector(rayDirProj, t);

        // Check if valid
        const px = (rayPosProj.x * fx / finalDepth) + cx - 0.5;
        const py = (rayPosProj.y * fy / finalDepth) + cy - 0.5;

        if (px >= 0 && px < imgWidth && py >= 0 && py < imgHeight) {
          // Transform back to world space
          const hitPointWorld = rayPosProj.applyMatrix4(projector.matrixWorld);
          console.log(`Raycast converged in ${iterations} iterations at pixel (${px.toFixed(1)}, ${py.toFixed(1)})`);
          return hitPointWorld;
        }
      }

      console.log('Raycast failed to find intersection');
      return null;
    }

    // Double-click to enter orbit mode
    renderer.domElement.addEventListener('dblclick', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      const hitPoint = raycastPointCloud(mouseX, mouseY);

      if (hitPoint) {
        // Create red marker at hit point
        createHitMarker(hitPoint);

        orbitCenter.copy(hitPoint);
        orbitDistance = camera.position.distanceTo(orbitCenter);

        const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
        orbitTheta = Math.atan2(offset.x, offset.z);
        orbitPhi = Math.acos(offset.y / orbitDistance);

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        animationStartPos.copy(camera.position);
        animationStartQuat.copy(camera.quaternion);
        animationTargetPos.copy(orbitCenter).add(new THREE.Vector3(x, y, z));

        const tempCamera = new THREE.PerspectiveCamera();
        tempCamera.position.copy(animationTargetPos);
        tempCamera.lookAt(orbitCenter);
        animationTargetQuat.copy(tempCamera.quaternion);

        isAnimating = true;
        animationProgress = 0;
        isOrbitMode = true;

        document.getElementById('mode').textContent = 'Orbit Mode';
        updateControls('orbit');
      }
    });

    // Mouse controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (e.button === 0) {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        isDragging = false;
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      if (isAnimating) {
        isAnimating = false;
      }

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      if (isOrbitMode) {
        orbitTheta -= deltaX * mouseSensitivity;
        orbitPhi -= deltaY * mouseSensitivity;
        orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
        camera.lookAt(orbitCenter);
      } else {
        euler.setFromQuaternion(camera.quaternion);
        euler.y -= deltaX * mouseSensitivity;
        euler.x -= deltaY * mouseSensitivity;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        camera.quaternion.setFromEuler(euler);
      }

      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    // Mouse wheel for zoom
    renderer.domElement.addEventListener('wheel', (e) => {
      if (isOrbitMode) {
        e.preventDefault();

        if (isAnimating) {
          isAnimating = false;
        }

        const zoomSpeed = 0.001;
        orbitDistance += e.deltaY * zoomSpeed * orbitDistance;
        orbitDistance = Math.max(0.1, Math.min(1000, orbitDistance));

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
        camera.lookAt(orbitCenter);
      }
    });

    // Touch controls for mobile
    let touches = [];
    let lastTouchDistance = 0;
    let lastTouchCenter = { x: 0, y: 0 };
    let lastTapTime = 0;
    let lastTapPosition = { x: 0, y: 0 };
    let touchStartTime = 0;
    let touchStartPosition = { x: 0, y: 0 };
    let longPressTimer = null;

    renderer.domElement.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);

      if (touches.length === 1) {
        // Track for double tap and long press
        touchStartTime = Date.now();
        touchStartPosition = { x: touches[0].clientX, y: touches[0].clientY };

        // Set up long press detection (800ms)
        longPressTimer = setTimeout(() => {
          // Reset view on long press
          camera.position.set(0, 0, 0);
          camera.quaternion.set(0, 0, 0, 1);
          isOrbitMode = false;
          isAnimating = false;
          document.getElementById('mode').textContent = 'Free Camera';
          updateControls('free');
        }, 800);
      } else if (touches.length === 2) {
        // Cancel long press if second finger added
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }

        // Calculate initial distance for pinch
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);

        // Calculate center point for two-finger pan
        lastTouchCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);

      // Cancel long press on move
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      if (touches.length === 2 && !isOrbitMode && !isAnimating) {
        // Two-finger gestures in free camera mode
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);

        const currentCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };

        // Pinch to zoom (move forward/backward) - halved sensitivity
        const distanceDelta = currentDistance - lastTouchDistance;
        const zoomSpeed = 0.005;
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(forward, distanceDelta * zoomSpeed);

        // Two-finger pan for translation (up/down, left/right) - halved and inverted
        const centerDeltaX = currentCenter.x - lastTouchCenter.x;
        const centerDeltaY = currentCenter.y - lastTouchCenter.y;
        const panSpeed = 0.0025;

        const right = new THREE.Vector3(1, 0, 0);
        right.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(right, -centerDeltaX * panSpeed);

        const up = new THREE.Vector3(0, 1, 0);
        camera.position.addScaledVector(up, centerDeltaY * panSpeed);

        lastTouchDistance = currentDistance;
        lastTouchCenter = currentCenter;
      } else if (touches.length === 2 && isOrbitMode) {
        // Two-finger gestures in orbit mode - pinch zoom only
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);

        if (isAnimating) {
          isAnimating = false;
        }

        // Pinch to change orbit distance - halved sensitivity
        const distanceDelta = currentDistance - lastTouchDistance;
        const zoomSpeed = 0.005;
        orbitDistance -= distanceDelta * zoomSpeed;
        orbitDistance = Math.max(0.1, Math.min(1000, orbitDistance));

        const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        const y = orbitDistance * Math.cos(orbitPhi);
        const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

        camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
        camera.lookAt(orbitCenter);

        lastTouchDistance = currentDistance;
      } else if (touches.length === 1 && !isOrbitMode && !isAnimating) {
        // Single finger drag for look around (like mouse drag)
        const touch = touches[0];
        if (previousMousePosition.x !== 0) {
          const deltaX = touch.clientX - previousMousePosition.x;
          const deltaY = touch.clientY - previousMousePosition.y;

          euler.setFromQuaternion(camera.quaternion);
          euler.y -= deltaX * mouseSensitivity;
          euler.x -= deltaY * mouseSensitivity;
          euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
          camera.quaternion.setFromEuler(euler);
        }
        previousMousePosition = { x: touch.clientX, y: touch.clientY };
      } else if (touches.length === 1 && isOrbitMode) {
        // Single finger drag to rotate orbit
        const touch = touches[0];
        if (previousMousePosition.x !== 0) {
          const deltaX = touch.clientX - previousMousePosition.x;
          const deltaY = touch.clientY - previousMousePosition.y;

          if (isAnimating) {
            isAnimating = false;
          }

          const rotateSpeed = 0.005;
          orbitTheta -= deltaX * rotateSpeed;
          orbitPhi -= deltaY * rotateSpeed;
          orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));

          const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
          const y = orbitDistance * Math.cos(orbitPhi);
          const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

          camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
          camera.lookAt(orbitCenter);
        }
        previousMousePosition = { x: touch.clientX, y: touch.clientY };
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchend', (e) => {
      e.preventDefault();

      // Cancel long press timer
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      const endTime = Date.now();
      const endPosition = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };

      touches = Array.from(e.touches);

      if (touches.length < 2) {
        lastTouchDistance = 0;
      }

      if (touches.length === 0) {
        previousMousePosition = { x: 0, y: 0 };

        // Check for double tap (like double click)
        const tapDuration = endTime - touchStartTime;
        const tapDistance = Math.sqrt(
          Math.pow(endPosition.x - touchStartPosition.x, 2) +
          Math.pow(endPosition.y - touchStartPosition.y, 2)
        );
        const timeSinceLastTap = endTime - lastTapTime;
        const distanceFromLastTap = Math.sqrt(
          Math.pow(endPosition.x - lastTapPosition.x, 2) +
          Math.pow(endPosition.y - lastTapPosition.y, 2)
        );

        // It's a tap if: quick (< 300ms), minimal movement (< 10px)
        const isTap = tapDuration < 300 && tapDistance < 10;

        if (isTap && timeSinceLastTap < 300 && distanceFromLastTap < 50) {
          // Double tap detected - enter orbit mode
          const rect = renderer.domElement.getBoundingClientRect();
          const mouseX = ((endPosition.x - rect.left) / rect.width) * 2 - 1;
          const mouseY = -((endPosition.y - rect.top) / rect.height) * 2 + 1;

          const hitPoint = raycastPointCloud(mouseX, mouseY);

          if (hitPoint) {
            // Create red marker at hit point
            createHitMarker(hitPoint);

            orbitCenter.copy(hitPoint);
            orbitDistance = camera.position.distanceTo(orbitCenter);

            const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
            orbitTheta = Math.atan2(offset.x, offset.z);
            orbitPhi = Math.acos(offset.y / orbitDistance);

            const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
            const y = orbitDistance * Math.cos(orbitPhi);
            const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

            animationStartPos.copy(camera.position);
            animationStartQuat.copy(camera.quaternion);
            animationTargetPos.copy(orbitCenter).add(new THREE.Vector3(x, y, z));

            const tempCamera = new THREE.PerspectiveCamera();
            tempCamera.position.copy(animationTargetPos);
            tempCamera.lookAt(orbitCenter);
            animationTargetQuat.copy(tempCamera.quaternion);

            isAnimating = true;
            animationProgress = 0;
            isOrbitMode = true;

            document.getElementById('mode').textContent = 'Orbit Mode';
            updateControls('orbit');
          }

          // Reset for next double tap detection
          lastTapTime = 0;
          lastTapPosition = { x: 0, y: 0 };
        } else if (isTap) {
          // Single tap - record for potential double tap
          lastTapTime = endTime;
          lastTapPosition = endPosition;
        }
      }
    }, { passive: false });

    // LIF file loading handler
    document.getElementById('lif-file-input').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const statusEl = document.getElementById('lif-status');
      statusEl.textContent = 'Loading...';
      statusEl.style.color = '#ffaa00';

      try {
        // Load LIF file and create projectors
        const result = await loadLifFile(file);

        if (result.projectors.length === 0) {
          throw new Error('No views found in LIF file');
        }

        // Store all loaded projectors
        loadedProjectors = result.projectors;

        // Remove old projector from scene
        scene.remove(projector);

        // Use first view (views[0])
        const newProjector = result.projectors[0];
        scene.add(newProjector);

        // Update global projector reference
        window.projector = newProjector;
        projector = newProjector; // Update local reference too

        // Add axes helper to new projector
        const newAxesHelper = new THREE.AxesHelper(0.5);
        newProjector.add(newAxesHelper);

        // Populate view selector dropdown if multiple views
        const viewSelect = document.getElementById('view-select');
        const viewSelector = document.getElementById('view-selector');
        viewSelect.innerHTML = '';

        for (let i = 0; i < result.projectors.length; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = `View ${i}`;
          viewSelect.appendChild(option);
        }

        // Show view selector if multiple views
        if (result.projectors.length > 1) {
          viewSelector.style.display = 'block';
        } else {
          viewSelector.style.display = 'none';
        }

        // Update point count display
        const pointCount = newProjector.width * newProjector.height;
        document.getElementById('point-count').textContent = pointCount.toLocaleString();

        // Position camera at the projector's location (view pose)
        camera.position.copy(newProjector.position);
        camera.quaternion.copy(newProjector.quaternion);

        // Store as new initial position for reset
        initialCameraPosition.copy(newProjector.position);
        initialCameraQuaternion.copy(newProjector.quaternion);

        // Check if we should start in orbit mode
        if (result.orbitCenter) {
          // Create red marker at orbit center
          createHitMarker(result.orbitCenter);

          // Set up orbit mode
          orbitCenter.copy(result.orbitCenter);
          orbitDistance = camera.position.distanceTo(orbitCenter);

          const offset = new THREE.Vector3().subVectors(camera.position, orbitCenter);
          orbitTheta = Math.atan2(offset.x, offset.z);
          orbitPhi = Math.acos(offset.y / orbitDistance);

          const x = orbitDistance * Math.sin(orbitPhi) * Math.sin(orbitTheta);
          const y = orbitDistance * Math.cos(orbitPhi);
          const z = orbitDistance * Math.sin(orbitPhi) * Math.cos(orbitTheta);

          animationStartPos.copy(camera.position);
          animationStartQuat.copy(camera.quaternion);
          animationTargetPos.copy(orbitCenter).add(new THREE.Vector3(x, y, z));

          const tempCamera = new THREE.PerspectiveCamera();
          tempCamera.position.copy(animationTargetPos);
          tempCamera.lookAt(orbitCenter);
          animationTargetQuat.copy(tempCamera.quaternion);

          isAnimating = true;
          animationProgress = 0;
          isOrbitMode = true;

          document.getElementById('mode').textContent = 'Orbit Mode (auto)';
          updateControls('orbit');

          console.log('Auto-orbit mode enabled with convergence point:', orbitCenter);
        } else {
          isOrbitMode = false;
          isAnimating = false;
          document.getElementById('mode').textContent = 'Free Camera';
          updateControls('free');

          console.log('No orbit center from stereo_render_data, starting in free camera mode');
        }

        console.log('Camera positioned at view location:', camera.position, camera.quaternion);
        console.log('Stored as initial position for reset (R key)');

        statusEl.textContent = `Loaded: ${newProjector.width}x${newProjector.height} (${result.projectors.length} view${result.projectors.length > 1 ? 's' : ''})`;
        statusEl.style.color = '#00ff00';

        // Helper function to update view info display
        function updateViewInfo(proj) {
          document.getElementById('view-info').style.display = 'block';
          document.getElementById('view-pos').textContent =
            `(${proj.position.x.toFixed(4)}, ${proj.position.y.toFixed(4)}, ${proj.position.z.toFixed(4)})`;

          // Format quaternion
          const quat = proj.quaternion;
          document.getElementById('view-rot').textContent =
            `(${quat.x.toFixed(3)}, ${quat.y.toFixed(3)}, ${quat.z.toFixed(3)}, ${quat.w.toFixed(3)})`;

          document.getElementById('view-fx').textContent = proj.intrinsics.fx.toFixed(2);
          document.getElementById('view-fy').textContent = proj.intrinsics.fy.toFixed(2);
          document.getElementById('view-cx').textContent = proj.intrinsics.cx.toFixed(2);
          document.getElementById('view-cy').textContent = proj.intrinsics.cy.toFixed(2);
          document.getElementById('view-invz-min').textContent = proj.invDepthRange.min.toFixed(6);
          document.getElementById('view-invz-max').textContent = proj.invDepthRange.max.toFixed(6);
          document.getElementById('view-baseline').textContent = (proj.invDepthRange.baseline || 1.0).toFixed(4);
        }

        // Update view info for first view
        updateViewInfo(newProjector);

        console.log('LIF file loaded successfully');
        console.log('  Views:', result.projectors.length);
        console.log('  Dimensions:', newProjector.width, 'x', newProjector.height);
        console.log('  Position:', newProjector.position);
        console.log('  Rotation (quaternion):', newProjector.quaternion);

      } catch (error) {
        console.error('Failed to load LIF file:', error);
        statusEl.textContent = 'Error: ' + error.message;
        statusEl.style.color = '#ff0000';
      }
    });

    // View selector change handler
    document.getElementById('view-select').addEventListener('change', (e) => {
      const viewIndex = parseInt(e.target.value);

      if (viewIndex >= 0 && viewIndex < loadedProjectors.length) {
        // Remove current projector from scene
        scene.remove(projector);

        // Add selected view projector
        const selectedProjector = loadedProjectors[viewIndex];
        scene.add(selectedProjector);

        // Update global reference
        window.projector = selectedProjector;
        projector = selectedProjector;

        // Update initial position for reset (but don't move camera yet)
        initialCameraPosition.copy(selectedProjector.position);
        initialCameraQuaternion.copy(selectedProjector.quaternion);

        // Update view info display
        document.getElementById('view-pos').textContent =
          `(${selectedProjector.position.x.toFixed(4)}, ${selectedProjector.position.y.toFixed(4)}, ${selectedProjector.position.z.toFixed(4)})`;

        const quat = selectedProjector.quaternion;
        document.getElementById('view-rot').textContent =
          `(${quat.x.toFixed(3)}, ${quat.y.toFixed(3)}, ${quat.z.toFixed(3)}, ${quat.w.toFixed(3)})`;

        document.getElementById('view-fx').textContent = selectedProjector.intrinsics.fx.toFixed(2);
        document.getElementById('view-fy').textContent = selectedProjector.intrinsics.fy.toFixed(2);
        document.getElementById('view-cx').textContent = selectedProjector.intrinsics.cx.toFixed(2);
        document.getElementById('view-cy').textContent = selectedProjector.intrinsics.cy.toFixed(2);
        document.getElementById('view-invz-min').textContent = selectedProjector.invDepthRange.min.toFixed(6);
        document.getElementById('view-invz-max').textContent = selectedProjector.invDepthRange.max.toFixed(6);
        document.getElementById('view-baseline').textContent = (selectedProjector.invDepthRange.baseline || 1.0).toFixed(4);

        // Update point count
        const pointCount = selectedProjector.width * selectedProjector.height;
        document.getElementById('point-count').textContent = pointCount.toLocaleString();

        console.log(`Switched to view ${viewIndex}`);
      }
    });

    // Animation loop
    let lastTime = 0;
    let frameCount = 0;
    let fpsFrameCount = 0;
    let fpsUpdateTime = 0;

    renderer.setAnimationLoop((time) => {
      const deltaTime = (time - lastTime) / 1000;
      lastTime = time;
      frameCount++;
      fpsFrameCount++;

      // Update FPS counter and camera position
      if (time - fpsUpdateTime >= 500) {
        const fps = Math.round((fpsFrameCount * 1000) / (time - fpsUpdateTime));
        document.getElementById('fps').textContent = fps;
        fpsFrameCount = 0;
        fpsUpdateTime = time;

        // Update camera position display
        const pos = camera.position;
        document.getElementById('camera-pos').textContent =
          `(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`;
      }

      // Camera animation
      if (isAnimating) {
        animationProgress += deltaTime / animationDuration;

        if (animationProgress >= 1.0) {
          animationProgress = 1.0;
          isAnimating = false;
        }

        const t = animationProgress < 0.5
          ? 2 * animationProgress * animationProgress
          : 1 - Math.pow(-2 * animationProgress + 2, 2) / 2;

        camera.position.lerpVectors(animationStartPos, animationTargetPos, t);
        camera.quaternion.slerpQuaternions(animationStartQuat, animationTargetQuat, t);
      }

      // WASD movement
      if (!isOrbitMode && !isAnimating) {
        const moveVector = new THREE.Vector3();
        if (moveState.forward) moveVector.z -= 1;
        if (moveState.backward) moveVector.z += 1;
        if (moveState.left) moveVector.x -= 1;
        if (moveState.right) moveVector.x += 1;
        if (moveState.up) moveVector.y += 1;
        if (moveState.down) moveVector.y -= 1;

        if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          moveVector.applyQuaternion(camera.quaternion);
          moveVector.multiplyScalar(moveSpeed * deltaTime);
          camera.position.add(moveVector);
        }
      }

      renderer.render(scene, camera);
    });
  </script>
</body>

</html>
